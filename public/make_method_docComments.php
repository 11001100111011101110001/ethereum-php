<?php

/**
 * @file
 * Generate a readme describin Ethereum public methods.
 *
 * We generating from resources/ethjs-schema.json -> objects.
 *
 * @ingroup generators
 */

use Ethereum\EthDataTypePrimitive;
require_once __DIR__ . '/generator-commons.php';

/**
 * @var string TARGET_PATH Generator destination.
 */
define('TARGET_PATH', '../src/helpers/ethMethodsDoc.php');

/**
 * @var bool ACCESS Deny public access to this generator.
 */
define('IS_PUBLIC', true);

/**
 * Better disable access in production.
 */
if (!IS_PUBLIC) {
    header("HTTP/1.1 401 Unauthorized");
    die('ACCESS DENIED');
}

/**
 * @var array $schema Decoded ethjs-schema.
 */
$schema = getSchema();


$file_header = <<<EOF
<?php
/**
 * @file
 * This is a file generated by public/make_method_docComments.php.
 * It is an Experiment on how to document the Ethereum class methods, as they are defined by schema and not in code. 
 */

EOF;


/**
 * @var array $lines Generated code lines.
 */
$lines = array();
$data_types = array();

foreach ($schema['methods'] as $method_name => $params) {

    echo "<h3>" . $method_name . "</h3>";

    $class_name = makeClassName($method_name);
    printMe('Class name base', $class_name);

    $valid_arguments = $params[0];
    $argument_class_names = [];
    if (count($valid_arguments)) {

        printMe('Valid arguments', $valid_arguments);

        // Get argument definition Classes.
        foreach ($valid_arguments as $type) {
            $primitiveType = EthDataTypePrimitive::typeMap($type);
            if ($primitiveType) {
                $argument_class_names[] = $primitiveType;
            } else {
                $argument_class_names[] = $type;
            }
        }
        printMe('Valid arguments class names', $argument_class_names);
    }

    $return_type = $params[1];
    printMe('Return value type', $return_type);
    addDataType($return_type);

    $return_type_string = is_array($return_type) ? $return_type[0] : $return_type;

    $method_data = [
        "/**",
        " * @fn public $return_type_string $method_name()",
        " * @brief $class_name",
        " * @details See [Ethereum Wiki $method_name](https://github.com/ethereum/wiki/wiki/JSON-RPC#" . strtolower($method_name) . ")",
    ];

    // Arguments.
    foreach ($argument_class_names as $param) {
        $method_data[] = " * @param " . $param;
    }

    // Return values.
    if (is_array($return_type)) {
        $method_data[] = " * @return array ";
        $method_data[] = " *    Array of " . EthDataTypePrimitive::typeMap($return_type[0]);
    }
    else if (is_string($return_type)){
        $method_data[] = " * @return " . EthDataTypePrimitive::typeMap($return_type);
    }
    else {
        throw new \Exception('Unknown Return type in schema.');
    }
    $method_data[] = " */\n\n";

    // Merge into Global lines.
    $lines = array_merge($lines, $method_data);
    echo "<hr />";
}

// Finally combine all into one file.
$content_lines = array_merge(
    // Add includes
    makeTypeIncludes($data_types),
    array("\n"),
    // Add Content
    $lines
);
file_put_contents(TARGET_PATH , $file_header . implode("\n", $content_lines));

function addDataType ($type) {
    global $data_types;

    if (is_array($type)) {
        foreach ($type as $subtype) {
            if (!in_array($subtype, $data_types)) {
                $data_types[] = $subtype;
            }
        }
    }
    else {
        // Add type to $data_types so we can generate e.g. 'use Ethereum\EthS;' later.
        if (!in_array($type, $data_types)) {

            // Special case for eth_syncing which returns Object or false.
            if (strpos($type, '|')) {
                // TODO This is actually very weired in the Schema: We have an "or" in Return values.
                // For now we just include both types, but this requires deeper investigation how to handle that.
                foreach (explode('|', $type) as $t) {
                    if (!in_array($t, $data_types)) {
                        $data_types[] = $t;
                    }
                }
            }
            else {
                $data_types[] = $type;
            }
        }
    }
}

function makeTypeIncludes($data_types) {
    $return = array();
    foreach ($data_types as $type) {
        $return[] = 'use Ethereum\\' . classNamebyType ($type) . ';';
    }
    return $return;
}

function classNamebyType ($type) {
    if (file_exists(__DIR__ . "/../src/$type.php")) {
        // This should be a complex data type (no Eth prefix).
        return $type;
    }
    else if (file_exists(__DIR__ . "/../src/Eth$type.php")) {
        // This should be a primitive data type (with Eth prefix).
        return "Eth$type";
    }
    else {
        throw new \Exception('Schema wants a type we do not have');
    }
}
