<?php

namespace Ethereum;

use Graze\GuzzleHttp\JsonRpc\Client as RpcClient;
use Ethereum\EthS;
use Ethereum\EthD20;
use Ethereum\EthD32;
use Ethereum\EthDataTypePrimitive;


/**
 * Ethereum JsonRPC API for PHP.
 *
 * Implements Ethereum JsonRPC API for PHP
 *   https://github.com/ethereum/wiki/wiki/JSON-RPC.
 *
 * This part of the Drupal Ethereum Module:
 * https://groups.drupal.org/ethereum
 *
 * Ethereum class is based on ethjs-schema by Nick Dodson.
 *   https://github.com/digitaldonkey/ethjs-schema
 */
class Ethereum extends EthereumStatic {

  private $definition;
  private $methods;
  protected $id = 0;
  public $client;
  public $debugHtml = '';

  /**
   * Constructing Ethereum Class.
   *
   * Remarks:
   * Ethereum class is based on ethjs-schema.json file.
   * - Everything is typed. All data types extend EthDataType class.
   * - Primitive data have a mostly common interface. See EthDataTypePrimitive.
   * - Complex data types (See "objects" in schema.json) are generated by
   *   script. This guarantees consistent type handling. Changes to the
   *   generated need to be implemented in make_datatypes.php.
   * - Methods are typed based on ethjs-schema and implemented as Closure calls,
   *   which makes this constructor complex, but ensures consistent typing.
   *
   * @param string $url
   *   Connection to Ethereum node. E.g:
   *   http://localhost:8545 or https://mainnet.infura.io/drupal.
   * @param bool $debug
   *   Provide debug info.
   */
  public function __construct($url) {

    // define('ETHEREUM_KECCAK_EXEC', '/opt/local/bin/keccak   --ethereum --string "#VALUE#"');

    $this->client = RpcClient::factory($url, array(
      // Debug JsonRPC requests.
      'debug' => FALSE,
    ));

    $schema_path = substr(__DIR__, 0, -strlen('src')) . 'ethjs-schema.json';
    $this->definition = json_decode(file_get_contents($schema_path), TRUE);;

    foreach ($this->definition['methods'] as $name => $params) {
      ${$name} = function () {

        $request_params = array();

        // Get name of called function.
        $method = debug_backtrace()[2]['args'][0];
        $this->debug('Called function name', $method);

        // Get call and return parameters and types.
        $param_definition = $this->definition['methods'][$method];

        // Arguments send with function call.
        $valid_arguments = $param_definition[0];
        $argument_class_names = array();
        if (count($valid_arguments)) {
          $this->debug('Valid arguments', $valid_arguments);

          // Get argument definition Classes.
          foreach ($valid_arguments as $type) {
            $primitiveType = EthDataTypePrimitive::typeMap($type);
            if ($primitiveType) {
              $argument_class_names[] = $primitiveType;
            }
            else {
              $argument_class_names[] = $type;
            }
          }
          $this->debug('Valid arguments class names', $argument_class_names);
        }

        // Arguments send with function call.
        $args = func_get_args();
        if (count($args) && isset($argument_class_names)) {
          $this->debug('Arguments', $args);

          // Validate arguments.
          foreach ($args as $i => $arg) {

            if ($argument_class_names[$i] !== $arg->getType()) {
              throw new \InvalidArgumentException("Argument $i is " . $arg->getType() . " but expected $argument_class_names[$i] in $method().");
            }
            else {

              // Add value. Inconsistently booleans are not hexEncoded if they
              // are not data like in eth_getBlockByHash().
              if ($arg->isPrimitive() && $arg->getType() !== 'EthB') {
                $request_params[] = $arg->hexVal();
              }
              elseif ($arg->isPrimitive() && $arg->getType() === 'EthB') {
                $request_params[] = $arg->val();
              }
              else {
                $request_params[] = $arg->toArray();
              }
            }
          }
        }

        // Validate required parameters.
        if (isset($param_definition[2])) {
          $required_params = array_slice($param_definition[0], 0, $param_definition[2]);
          $this->debug('Required Params', $required_params);
        }

        if (isset($required_params) && count($required_params)) {
          foreach ($required_params as $i => $param) {
            if (!isset($request_params[$i])) {
              throw new \InvalidArgumentException("Required argument $i $argument_class_names[$i] is missing in $method().");
            }
          }
        }

        // Default block parameter required for function call.
        // See: https://github.com/ethereum/wiki/wiki/JSON-RPC#the-default-block-parameter.
        $require_default_block = FALSE;
        if (isset($param_definition[3])) {
          $require_default_block = $param_definition[3];
          $this->debug('Require default block parameter', $require_default_block);
        }
        if ($require_default_block) {
          $arg_is_set = FALSE;
          foreach ($argument_class_names as $i => $class) {
            if ($class === 'EthBlockParam' && !isset($request_params[$i])) {
              $request_params[$i] = 'latest';
            }
          }
        }

        // Return type.
        $return_type = $param_definition[1];
        $this->debug('Return value type', $return_type);

        $is_primitive = (bool) EthDataTypePrimitive::typeMap($return_type);

        if (is_array($return_type)) {
          $return_type_class = array(EthDataTypePrimitive::typeMap($return_type[0]));
        }
        elseif ($is_primitive) {
          $return_type_class = EthDataTypePrimitive::typeMap($return_type);
        }
        else {
          // Return Complex type.
          $return_type_class = $return_type;
        }
        $this->debug('Return value Class name ', $return_type_class);

        // Call.
        $this->debug('Final request params', $request_params);
        $value = $this->etherRequest($method, $request_params);

        // Workaround varying client implementations.
        $workaround_file = substr(__DIR__, 0, -3) . 'workarounds/' . $method . '.php';
        if (file_exists($workaround_file)) {
          require_once $workaround_file;
          $value = call_user_func('eth_workaround_' . $method, $value);
        }

        $return = $this->createReturnValue($value, $return_type_class, $method);
        $this->debug('Final return object', $return);
        $this->debug('<hr />');
        return $return;
      };
      // Binding above function.
      $this->methods[$name] = \Closure::bind(${$name}, $this, get_class());
    }
  }

  /**
   * Method call wrapper.
   *
   *
   */
  public function __call($method, $args) {

    // TODO CONSIDER IF NOT EXITST? To overwrite Functions locally?
    // Would be also good for web3_sha3(). But we might rename...

    if(is_callable($this->methods[$method])) {
      return call_user_func_array($this->methods[$method], $args);
    }
    else {
      throw new \InvalidArgumentException('Unknown Method: ' . $method);
    }
  }

  /**
   * Handle Return Value.
   *
   * @param string|array $value
   *   Returned value from JsonRPC request.
   * @param string $return_type_class
   *   Class name of the expected return type.
   * @param string $method
   *   Method name for error messages.
   *
   * @return object|array
   *   Expected object.
   *
   * @throws \Exception
   */
  public function createReturnValue($value, $return_type_class, $method) {
    $return = NULL;

    // Get return value type.
    $class_name = '\\Ethereum\\' . EthDataType::getTypeClass($return_type_class);
    // Is array ?
    $array_val = is_array($return_type_class);
    // Is primitive data type?
    $is_primitive = $class_name::isPrimitive();

    // Primitive array Values.
    if ($is_primitive && $array_val && is_array($value)) {
      // According to schema array returns will always have primitive values.
      $return = $this->valueArray($value, $class_name);
    }
    elseif ($is_primitive && !$array_val && !is_array($value)) {
      $return = new $class_name($value);
    }

    // Complex array types.
    if (!$is_primitive && !$array_val && is_array($value)) {
      $return = $this->arrayToComplexType($class_name, $value);
    }
    elseif (!$is_primitive) {
      // Returning empty of type.
      // Fixes get unknown block by number.
      //
      // TODO WHAT IF TYPE HAS REQUIRED VALUES
      // Should there be a default implementation for non existent types?
      // Like a Null Object? Should EthDataTypes have a test if they are valid?
      $return = new $class_name();
    }

    if (!$return && !is_array($return)) {
      throw new \Exception('Expected ' . $return_type_class . ' at ' . $method . ' (), couldn not be decoded. Value was: ' . print_r($value, TRUE));
    }
    return $return;
  }

  /**
   * Request().
   *
   * @param string $method
   *   JsonRPC method to be called.
   * @param array $params
   *   Request parameters. See Guzzle doc.
   */
  public function request($method, array $params = []) {
    $this->id++;
    return $this->client->send($this->client->request($this->id, $method, $params))->getRpcResult();
  }

  /**
   * Ethereum request.
   */
  public function etherRequest($method, $params = array()) {
    try {
      return $this->request($method, $params);
    }
    catch (\Exception $e) {
      if ($e->getCode() === 405) {
        return array(
          'error' => TRUE,
          'code' => 405,
          'message' => $e->getMessage(),
        );
      }
      else {
        throw $e;
      }
    }
  }


  /**
   * Get signature of a solidity method.
   *
   * Returns hash of the Smart contract method - it's signature.
   *
   * See:
   * https://github.com/ethereum/wiki/wiki/Ethereum-Contract-ABI#function-selector
   *
   * @param string $input
   *   Method signature.
   *
   * @return string
   *   Hash of the method signature.
   */
  public function getMethodSignature($input) {
    if ($this->isValidFunction($input)) {
      $keccac = $this->web3_sha3(new EthS($input));
      // The signature is 4bytes of the methods keccac hash. E.g: "0x00000000".
      return substr($keccac->hexVal(), 0, 10);
    }
    else {
      throw new \InvalidArgumentException("No valid (solidity) signature string provided.");
    }
  }

  /**
   * Keccak hash function.
   *
   * Ethereum JsonRPC provides web3.sha3(), but  making a JsonRPC call for that
   * seems costly. We define a hook here to allow local hashing.
   *
   * To use a external hash tool define ETHEREUM_KECCAK_EXEC in you app.
   * define(
   *   'ETHEREUM_KECCAK_EXEC',
   *   '/opt/local/keccak   --ethereum --string "#VALUE#"'
   * );
   * Also shell_exec requires PHP Save Mode to be Off.
   *
   * You may use https://github.com/gvanas/KeccakCodePackage
   * See: https://github.com/gvanas/KeccakCodePackage/issues/33
   *
   * Note:
   * The first 64 letters of the return value have to be the hash.
   *
   * Unlike web3's sha3 method suggests Ethereum is NOT using SHA3-256 standard
   * implementation (the NIST SHA3-256 became a standard later), but Keccak256.
   * Is is the pure Keccak[r=1088, c=512] implementation.
   *
   * @param string $string
   *   String to hash.
   *
   * @return string
   *   Keccak256 of the provided string.
   *
   * @throws \Exception
   *   If keccak hash does not match formal conditions.
   */
  public function phpKeccak256($string) {
    $return = NULL;

    if (defined('ETHEREUM_KECCAK_EXEC')) {
      $call = str_replace('#VALUE#', $string, ETHEREUM_KECCAK_EXEC);
      $return = $this->ensureHexPrefix(substr(shell_exec($call), 0, 64));
    }
    else {
      $ret = $this->web3_sha3(new EthS($string));
      $return = $ret->hexVal();
    }

    // Formal verification: Prefix + 64 Hex chars.
    if (!$return || strlen($return) !== 66 || !ctype_xdigit($this->removeHexPrefix($return))) {
      throw new \Exception('keccak256 returns a wrong value.');
    }
    return $return;
  }


  /**
   * PersonalEcRecover function.
   *
   * @param string $message
   *   UTF-8 text without prefix.
   * @param EthD $signature
   *   Hex value of the Message Signature.
   * @param EthD20 $public_key
   *   Hex version of the Public key (Ethereum Address).
   *
   * @return bool
   *   Returns TRUE if Public Key matches the signature.
   *
   * @throws \Exception
   *   If keccak hash does not match formal conditions.
   */
  public function personalEcRecover($message, EthD $signature, EthD20 $public_key) {
    $message_hash = $this->phpKeccak256($this->personalSignAddHeader($message));
    $address = $this->phpEcRecover(new EthD32($message_hash), $signature);
  }

  /**
   * EcRecover - Elliptic Curve Signature Verification.
   *
   * This function ecRecover is a wrapper to a solidity function (ececover).
   * See:
   * http://solidity.readthedocs.io/en/latest/miscellaneous.html?highlight=ecrecover
   *
   * Using this ecRecover-wrapper it is the recommended to use ecrecover in
   * order to  provide future performance improvements.
   *
   * EC recovery doses not require any blockchain interaction, it's just
   * freaky math. Considering libraries, PHP extensions or command
   * line C or node implementations.
   *
   * @param string $message_hash.
   *   Keccak-256 of message in hex
   *
   * @return string
   *   Keccak256 of the provided string.
   *
   * @throws \Exception
   *   If keccak hash does not match formal conditions.
   */
  public function phpEcRecover(EthD32 $message_hash, EthQ $v, EthD32 $r, EthD32 $s) {
    $return = NULL;

    define('ETHEREUM_ECRECOVER', '/opt/local/bin/ecrecover #m# #v# #r# #s#');
    // Elliptic Curve recovery
    // Can be implemented in various ways. Currently under investigation.
    // The last option however is using a JsonRPC call.
    if (defined('ETHEREUM_ECRECOVER')) {
      $call = str_replace(
        array('#m#', '#v#', '#r#', '#s#'),
        array($message_hash->hexVal(), $v->hexVal(), $r->hexVal(), $s->hexVal()),
        ETHEREUM_ECRECOVER
      );
      $address = new EthD20($this->ensureHexPrefix(substr(shell_exec($call), 0, 42)));
    }
    else {
      // $address = $this->ecrecovery($message_hash, $v, $r, $s);
      // $this->contractEcRecover($message, EthD $signature, EthD20 $public_key)
      throw new \Exception('EC verifications on contract level is not implemented yet.');
    }

    // Formal verification: Prefix + 64 Hex chars.
    if (!is_a($address, 'Ethereum\EthD20')) {
      throw new \Exception('ecRecover returns a wrong value.');
    }
    return $address->hexVal();
  }


  /**
   * Contract based EcRecover.
   *
   * @param string $message
   *   UTF-8 text without prefix.
   * @param EthD $signature
   *   Hex value of the Message Signature.
   * @param EthD20 $public_key
   *   Hex version of the Public key (Ethereum Address).
   *
   * @return bool
   *   Returns TRUE if Public Key matches the signature.
   *
   * @throws \Exception
   *   If keccak hash does not match formal conditions.
   */
  public function contractEcRecover($message, EthD $signature, EthD20 $public_key) {
    $contract_addr = '0x3bbb367afe5075e0461f535d6ed2a640822edb1c';

//    77d32e94 ecrecovery(bytes32,bytes)
//    39cdde32 ecverify(bytes32,bytes,address)

    $message_hash = $this->phpKeccak256($this->personalSignAddHeader($message));
    $address = $this->phpEcRecover(new EthD32($message_hash), $signature);
  }

  /**
   * Debug Helper.
   *
   * @param string $title
   *   Any HTML. Will be printed bold.
   * @param string|object|array $content
   *   Content will be printed in appropriate format.
   *
   * @return string
   *   Debug HTML output.
   */
  public function debug($title, $content = NULL) {
    $return = '';
    $return .= '<p style="margin-left: 1em"><b>' . $title . "</b></p>";
    if ($content) {
      $return .= '<pre style="background: rgba(0,0,0, .1); margin: .5em; padding: .25em; ">';
      if (is_object($content) || is_array($content)) {
        ob_start();
        var_dump($content);
        $return .= ob_get_clean();
      }
      else {
        $return .= ($content);
      }
      $return .= "</pre>";
    }
    $this->debugHtml .= $return;
    return $return;
  }

}
